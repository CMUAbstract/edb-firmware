# Available configuration options to be set in the master makefile

# Enable communication to host workstation via a UART module
#
ifeq ($(CONFIG_HOST_UART),1)
	CFLAGS += -DCONFIG_HOST_UART
endif

# Enable communication to target device via a UART module
#
ifeq ($(CONFIG_TARGET_UART),1)
	CFLAGS += -DCONFIG_TARGET_UART
endif

# Enable code for decoding the RF protocol
# 		Currently, this is disabled because it causes spurious interrupts.
#
#       TODO: setup RF pins only upon cmd to monitor RF because otherwise we
#       get spurious interrupts on RX pin
#
ifeq ($(CONFIG_ENABLE_RF_PROTOCOL_MONITORING),1)
	CFLAGS += -DCONFIG_ENABLE_RF_PROTOCOL_MONITORING

# 		When parsing RFID messages, use calculated bounds on symbol duration
# 			For some symbols, their duration depends on the duration of
# 			previous symbols (e.g. some symbol durations are defined in
# 			terms of Tari symbol duration). This flag turns on implementation
# 			of symbol time validity checks using such dynamic bounds
# 			calculated at runtime.  This is a true implementation of the
# 			spec, as opposed to static magic bounds chosen by trial and error
# 			in a particular setup, However this is expensive in terms of
# 			cycles (too expensive to work?).
ifeq ($(CONFIG_RFID_DECODER_RUNTIME_BOUNDS),1)
	CFLAGS += -DCONFIG_RFID_DECODER_RUNTIME_BOUNDS
endif

endif # CONFIG_ENABLE_RF_PROTOCOL_MONITORING

# Enable listening and recording communication on I2C bus
# 		TODO: this is not currently implemented
ifeq ($(CONFIG_ENABLE_I2C_MONITORING),1)
	CFLAGS += -DCONFIG_ENABLE_I2C_MONITORING
endif

# Enable a time-keeping timer (systick)
ifeq ($(CONFIG_SYSTICK),1)
	CFLAGS += -DCONFIG_SYSTICK

# Maintain 32-bit system time (systick)
# 		Handle overflow in system timer and increment a 32-bit timestamp.
ifeq ($(CONFIG_SYSTICK_32BIT),1)
	CFLAGS += -DCONFIG_SYSTICK_32BIT
endif

endif # CONFIG_SYSTICK

# Capacitor charge implemented by a PWM with a control loop around the duty-cycle
# 		The alternative is an "valve" method of raising a GPIO high and watching
#       the voltage level with ADC or comparator and pulling the GPIO low once
#       the target threshold is crossed.
#
ifeq ($(CONFIG_PWM_CHARGING),1)
	CFLAGS += -DCONFIG_PWM_CHARGING
endif

# Two alternative workarounds for the crashes due to voltage ramp on startup
# 		  The problem these work around is crashes that occur at arbitrary times
#         after startup. The crash is either a wild jump or an oscillator
#         fault.
#
#         At first glance crashes are somewhat consistent and seem
#         correlated to peripheral activity. For example, not doing anything
#         with the UART might seem to get rid of the crash, or, even
#         stranger, re-arranging C-code, like removing code that's in an
#         if-branch that is never taken, or replacing a function call with an
#         inline invocation, all appear to consistently influence whether a
#         crash happens or not.
#
#         However, the underlying issue is traced to some kind of
#         non-fail-stop failure during startup that corrupts subsequent
#         execution. Furthermore, the problem has to do with the Power
#         Management Module -- it either generates false events (like
#         overvoltage), or does not generate correct events in time. In
#         particular, there are multiple errata about it, including a false
#         overvoltage even if voltage ramps up too quickly.
#
#         NOTE: Unfortunately, these workarounds do not get rid of the same kind
#               of crash that happens with debugger attached (either CCSv6 or
#               mspdebug).
#
ifeq ($(CONFIG_STARTUP_VOLTAGE_WORKAROUND),disable-pmm)
	CFLAGS += -DCONFIG_STARTUP_VOLTAGE_WORKAROUND_DISABLE_PMM
else ifeq ($(CONFIG_STARTUP_VOLTAGE_WORKAROUND),delay)
	CFLAGS += -DCONFIG_STARTUP_VOLTAGE_WORKAROUND_DELAY
endif

# Enable pull-down on the debugger<->target interrupt line.
#
# 		  We watch for interrupts the target raises when the target requests
#         to enter active debug mode, such as upon hitting an internal or
#         external breakpoint. If the target is off or not present, then both
#         ends of this line are in high impedence mode (effectively
#         floating?). This does not seem to cause spurious interrupts, but if
#         this problem did arise, enabling pull-down resistors should solve
#         it.
#
#         NOTE: The pull-down causes energy interference (current is sourced
#         from the target when target drives this pin high), but the target
#         only drives this pin high for at most one cycle (signal
#         communication is exclusively done using one-cycle-long pulses).
#
ifeq ($(CONFIG_PULL_DOWN_ON_SIG_LINE),1)
	CFLAGS += -DCONFIG_PULL_DOWN_ON_SIG_LINE
endif

# Enable code to decode RFID transmissions from the target
#
ifeq ($(CONFIG_ENABLE_RF_TX_DECODING),1)
	CFLAGS += -DCONFIG_ENABLE_RF_TX_DECODING
endif

# Decode the RFID command payload bits (not only the command code)
# 	TODO: NOT IMPLEMENTED
#
ifeq ($(CONFIG_DECODE_RFID_CMD_PAYLOAD),1)
	CFLAGS += -DCONFIG_DECODE_RFID_CMD_PAYLOAD
endif

# Route serial decoder events to external pins
# 		For testing and tuning decoding of serial protocol over the signal
# 		line.
# 
ifeq ($(CONFIG_SIG_SERIAL_DECODE_PINS),1)
	CFLAGS += -DCONFIG_SIG_SERIAL_DECODE_PINS
endif


# Enable an auxiliary signal useful for triggering a scope
# 		A pulse is issued when a host command is ready for execution.
#
ifeq ($(CONFIG_SCOPE_TRIGGER_SIGNAL),1)
	CFLAGS += -DCONFIG_SCOPE_TRIGGER_SIGNAL
endif

# Enable breakpoints stored on the target-side 
# 		The number of such breakpoints is not limited by the number of
# 		codepoints pins. The downside is that to enable a passive breakpoint,
# 		the target must be interrupted first to enter interactive debugging
# 		mode and run the enable command in the console.
#
ifeq ($(CONFIG_ENABLE_PASSIVE_BREAKPOINTS),1)
	CFLAGS += -DCONFIG_ENABLE_PASSIVE_BREAKPOINTS
endif

# Enable handling of watchpoint (streaming to host and/or collecting a profile)
#
ifeq ($(CONFIG_ENABLE_WATCHPOINTS),1)
	CFLAGS += -DCONFIG_ENABLE_WATCHPOINTS
endif

# 		Enable feature to deliver watchpoint events to host via 'stream' cmd
#
ifeq ($(CONFIG_ENABLE_WATCHPOINT_STREAM),1)

ifneq ($(CONFIG_ENABLE_WATCHPOINTS),1)
$(error CONFIG_ENABLE_WATCHPOINT_STREAM requires CONFIG_ENABLE_WATCHPOINTS)
endif

	CFLAGS += -DCONFIG_ENABLE_WATCHPOINT_STREAM
endif

# 		Collect an energy profile using watchpoints
# 			An energy profile is a distribution of energy at each watchpoint
# 			event, where the distribution is given by the count in each
# 			quantized energy level.
#
ifeq ($(CONFIG_ENABLE_ENERGY_PROFILE),1)

ifneq ($(CONFIG_ENABLE_WATCHPOINTS),1)
$(error CONFIG_ENABLE_ENERGY_PROFILE requires CONFIG_ENABLE_WATCHPOINTS)
endif

	CFLAGS += -DCONFIG_ENABLE_ENERGY_PROFILE
endif


# Support entering and exiting active debug mode
# 		   The reason we have a switch are the limited resources
#          on the MCU that need to be shared (specifically, timers).
#          Right now, RFID TX decoding and debug mode cannot
#          co-exist.
# 
ifeq ($(CONFIG_ENABLE_DEBUG_MODE),1)
	CFLAGS += -DCONFIG_ENABLE_DEBUG_MODE

#	Support requests to enter debug mode initiated by the target
ifeq ($(CONFIG_ENABLE_TARGET_SIDE_DEBUG_MODE),1)
	CFLAGS += -DCONFIG_ENABLE_TARGET_SIDE_DEBUG_MODE
endif

endif

# Reset debug mode state machine when target detected to turn on
# 			The detection is done by monitoring Vreg rising to MCU_ON_THRES
#           using the comparator.
#  
#           This conflicts with other uses of the comparator: charge, discharge,
#           and energy breakpoint. All of these have alternative implementations
#           using the ADC.
#  
#           TODO: this should be enablable at runtime using a console command
#           	  from the host and persisted in an option dictionary (not
#           	  implemented)
ifeq ($(CONFIG_RESET_STATE_ON_BOOT),1)
	CFLAGS += -DCONFIG_RESET_STATE_ON_BOOT
endif

# Enable streaming voltages
# 		Requires a timer to be allocated for the ADC trigger (see
# 		TMRMOD_ADC_TRIGGER).
# 
ifeq ($(CONFIG_ENABLE_VOLTAGE_STREAM),1)
	CFLAGS += -DCONFIG_ENABLE_VOLTAGE_STREAM
endif

# Abort if a fault in the UART module is detected
# 		Indication: red led on, and iff error is overflow, then green led blinking.
#
ifeq ($(CONFIG_ABORT_ON_HOST_UART_ERROR),1)
	CFLAGS += -DCONFIG_ABORT_ON_HOST_UART_ERROR
endif

# Abort if RFID event buffer overflows (as opposed to dropping events)
#
ifeq ($(CONFIG_ABORT_ON_RFID_EVENT_OVERFLOW),1)
	CFLAGS += -DCONFIG_ABORT_ON_RFID_EVENT_OVERFLOW
endif

# Encode debugger state machine state onto pins
#
ifeq ($(CONFIG_STATE_PINS),1)
	CFLAGS += -DCONFIG_STATE_PINS
endif

# Enable pins for general-purpose event reporting (for debugging)
#
ifeq ($(CONFIG_EVENT_PINS),1)
	CFLAGS += -DCONFIG_EVENT_PINS
endif

# Encode RFID decoder state onto pins for debugging purposes
#
ifeq ($(CONFIG_RFID_DECODER_STATE_PINS),1)
	CFLAGS += -DCONFIG_RFID_DECODER_STATE_PINS
endif

# Clock testing mode: enter a blinker loop after configuring clocks
ifeq ($(CONFIG_CLOCK_TEST_MODE),1)
	CFLAGS += -DCONFIG_CLOCK_TEST_MODE
endif

# Configure MCU to output ACLK to a pin
# 		On edb board must "unplug" op amp buffers by disconnecting JP1
ifeq ($(CONFIG_ROUTE_ACLK_TO_PIN),1)
	CFLAGS += -DCONFIG_ROUTE_ACLK_TO_PIN
endif
